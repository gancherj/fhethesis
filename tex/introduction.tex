\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}
\chaptermark{Introduction}
\markboth{Introduction}{Introduction}

Cryptography is, in part, the study of providing security guarantees on information. There are many such guarantees, but we will be most concerned with that of \emph{secrecy}. When we say secrecy, what we mean is this: two parties, Alice and Bob, are communicating with each other over an insecure channel (such as the Internet), where they want to keep their communications secret from a third party, Eve.

%what's encryption
Many situations fit this model. One classic example is that Alice and Bob are agents of a military who are trying to give each other crucial strategic information, such as commands to a troop. Then, Eve is a member of the opposing military, who would very much like to learn where Alice and Bob's soldiers are moving. Another example is communicating with one's bank, where Alice is a customer of bank Bob, and Eve is maliciously listening in on Alice's communication to the bank. There are two basic goals to be achieved in this model: the first is that Alice and Bob can understand what each other is saying, and the second is that Eve cannot learn what their messages contain.

Generally, the way to achieve these two goals is through \emph{encryption}. Encryption is a process that, when given a \emph{key} ${\sf K}_E$, converts \emph{plaintexts} (i.e., messages) to \emph{ciphertexts}. Instead of Alice and Bob communicating directly in plaintext, they instead encrypt their messages and send the ciphertext. Then, the recipient will \emph{decrypt} the ciphertext using the secret key ${\sf K}_D$, to reveal the original message. (The keys ${\sf K}_E$ and ${\sf K}_D$ are generated together ahead of time.)

Encryption is constrained to meet the two above goals:
\begin{enumerate}
    \item Encryption is \emph{correct}: if Alice encrypts a message using ${\sf K}_E$, then Bob can retrieve the correct message by decrypting the ciphertext with ${\sf K}_D$.
    \item Encryption is \emph{secure}: if Alice encrypts a message using ${\sf K}_E$, then Eve cannot use the ciphertext to learn about the underlying message without access to ${\sf K}_D$.
\end{enumerate}

When many people think about encryption, they think of the Enigma machine or similar World War II-era systems. These systems are called \emph{ciphers}, and are \emph{symmetric} in nature: that is, the key for encryption, ${\sf K}_E$, is the same as the key for decryption, ${\sf K}_D$. In this setting, Alice and Bob both possess this shared key ${\sf K}$, so can both decrypt each other's ciphertexts. A more modern example of a cipher is AES (Advanced Encryption Standard), which is used throughout the Internet for secure communication.


The other possibility, which is the one we are concerned with, is the \emph{asymmetric} setting (also called the \emph{public-key} setting). Here, the encryption key (the \emph{public key}) ${\sf K}_E$ is different than the decryption key (or the \emph{secret key}) ${\sf K}_D$. In this setting, Bob publishes his public key ${\sf K}_E$ so that anybody can see it, but only he possesses the secret key ${\sf K}_D$. This is a very useful technique, since Alice is now able to securely send messages to Bob \emph{using only public information}. That is, Alice may speak privately to Bob without Alice and Bob agreeing to be spoken to in advance, since only Bob possesses ${\sf K}_D$. Compare this with the symmetric key setting, in which Alice and Bob need to agree on the secret key ${\sf K}$ beforehand.

One of the first major public-key encryption system was invented by Rivest, Shamir, and Adleman in 1977 \cite{rivest1978method}, now named the RSA scheme. Following their discovery, Rivest and others became interested in not only what was possible using public-key encryption alone, but also what \emph{else} was possible using the same mathematical techniques as is used in RSA and other contemporary public-key encryption systems.

The reason they conjectured that more was possible using public-key encryption is that ciphertexts encrypted under RSA somehow contained ``more structure'' than ciphertexts encrypted under symmetric-key ciphers. Generally, ciphers regard messages as \emph{collections of bits}; that is, many individual choices of $1$s or $0$s. Then, the goal of a cipher is to ``mix up'' these bits, and ``add in'' new bits, so that the output of the cipher looks random -- subject to the constraint that we can reverse all of the operations taken by the cipher, given the key. In contrast, RSA regards messages as \emph{integers}, and performs arithmetic operations on these integers so that the integer output of RSA looks random -- subject to the corresponding constraint that we can reverse all of the arithmetic operations taken by RSA, given the secret key.

Because RSA operates on integers instead of individual bits, it might make sense to \emph{operate arithmetically on ciphertexts}. That is, since each ciphertext of RSA is itself an integer, it may make sense to add or multiply integers, where it would not make sense to add or multiply individual bits. It is in this sense that RSA contains more structure than symmetric-key ciphers.

Abstracted out from RSA, we search for an operation on public-key ciphertexts in which an ``outside'' operation -- computed on the ciphertext -- corresponds in some way to an ``inside'' operation -- a computation on the \emph{plaintexts}. A sufficiently powerful system of this sort would be extremely useful, since in effect we would be \emph{computing on ciphertexts}. That is, given some program $P$ with data $x$ ($x$ could be some sensitive medical information, and $P$ some computation involving medical data), we could transform $x$ into a ciphertext $c$, and run $P$ on $c$ instead.

It turns out that, when computing with integers, ``sufficiently powerful'' means that it makes sense to both add and multiply ciphertexts. However, all ``classic'' public key encryption systems (such as RSA) are \emph{not} sufficiently powerful. For example, it turns out that it \emph{does} make sense to multiply RSA ciphertexts -- and indeed, we receive a valid encryption of the messages multiplied together -- but it does not make sense to add ciphertexts. The same limitation holds for other public-key encryption systems similar to RSA. Thus, it has been a major open question within cryptography whether or not encryption systems exist that do have sufficiently powerful operations; that is, if they can support both addition and multiplication. Encryption systems with this capability are called \emph{homomorphic} encryption systems.

Homomorphic encryption has immediate applications to banking, science involving sensitive data (such as genomics), providing secrecy guarantees on programs as well as data, encrypted search queries, and so on. In medicine, for example, one could imagine that everyone's medical record is stored encrypted on a cloud service. Patients would submit their eating habits and exercise routine to this cloud service, also under a layer of encryption. Using homomorphic encryption, this cloud service could then automatically warn patients of health complications, bad eating habits, and so on -- all without the cloud service having access to the patient's medical data. Since the data is encrypted, such a system could enable hospitals to legally share encrypted medical records with the cloud service. Without homomorphic encryption, such a service could not exist.

This question was first raised by Rivest et al.~in 1978 \cite{rivest1978data}. More than thirty years later, Craig Gentry answered this question in the affirmative in 2009, giving an explicit construction of a \emph{fully homomorphic encryption} (FHE) scheme.

This thesis outlines his construction, and presents the academic work surrounding and extending his result from 2009 to the present day.


\section*{Outline of Thesis}
The thesis is divided into six main chapters. In Chapter 1, we give the relevant background for the definitions of encryption and FHE. In Chapter 2, we present the theory of \emph{lattices}, which are used by all FHE schemes in some manner. In Chapter 3, we present Gentry's FHE construction. In Chapter 4, we present the DGHV scheme, which is an FHE scheme defined over integers, constructed by van Dijk et al.~In Chapter 5, we present the most recent forms of FHE, which are based on the learning with errors (LWE) problem. Finally, in Chapter 6, we sketch some applications of FHE.
